/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface FfiSafeAction {
  /** The timestamp of the happening of the action */
  ctime: number
  /** The time since the beginning of the script */
  timeline: number
  /** The type of the action */
  actionType: 'KeyPress' | 'KeyRelease' | 'MousePress' | 'MouseRelease' | 'MouseMove'
  /** The key of the action */
  actionKey: string
  /** The position of the action (only for mouse action) */
  actionPosition?: [x: number, y: number] | null
}
export interface FfiSafeScript {
  /** The name of the script, default to the timestamp of creation */
  name: string
  /** The timestamp of creation of the script */
  ctime: number
  /** The duration of the script in milliseconds */
  duration: number
  /** The actions to perform */
  actions: Array<FfiSafeAction>
}
/** the callback will be invoked in another thread in 3 seconds (will arg "hi -- i'm from another thread") */
export function callbackTest(callback: (v: string) => void): void
/** the task will be resolved in 3 seconds (will return "hi -- i'm from async task") */
export function asyncTaskTest(): Promise<string>
export type NodeRecorder = Recorder
export class Recorder {
  /**
   * create a new recorder
   * - record_type: the type of the recorder, can be "keyboard", "mouse" or "both"
   * - stop_signal: the signal to stop the recorder, can be one of valid 'CanonicalKey'
   */
  constructor(recordType: 'keyboard' | 'mouse' | 'both', stopSignal?: string | undefined | null)
  /**
   * Set the type of the action to be recorded
   *
   * This has no effect on the current recording. (The listener is set once `record_callback` or `record_async` is called.)
   */
  setRecordType(recordType: 'keyboard' | 'mouse' | 'both'): void
  /**
   * Set the key that stops the recording
   *
   * This has no effect on the current recording. (The signal is copied once `record_callback` or `record_async` is called.)
   */
  setStopSignal(stopSignal?: string | undefined | null): void
  /**
   * Start recording (The record will stop when the stop signal is received,
   * you can also use the `finish` to interrupt the recording manually).
   *
   * This will run in a separate thread (created by `std::thread::spawn`), so it will not block the main thread.
   * On the other hand, you may need to wait in the main thread for the recording to finish.
   * ---
   * see `record_async` for promise-like usage
   */
  recordCallback(onFinish: (v: FfiSafeAction) => void): void
  /** Interrupt the recording started by `record_callback` */
  finish(): void
  /**
   * Start recording (The record will not stop until the stop signal is received,
   * that is, you have to set the stop signal before calling this function or it will throw an error directly).
   *
   * This will run in a separate thread (created by `xxx`), so it will not block the main thread.
   * ---
   * see `record_callback` for callback-style usage
   */
  recordAsync(): Promise<unknown>
}
